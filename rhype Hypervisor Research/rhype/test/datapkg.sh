#! /usr/bin/env bash
#
# Copyright (C) 2005 Jimi Xenidis <jimix@watson.ibm.com>, IBM Corporation
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
#
# $Id$
#

#set -x

usage() {
    cat - <<EOF
usage: $prog [options]
    -h		Show this message and exit.
    -p		GNU tool prefix
    -O		BFD output target
    -B		BFD binary architecture
    -o		C file to create

EOF
}


prog=$0


while getopts "hp:O:B:o:z" OPT; do
  case $OPT in
  h) usage
     exit
     ;;
  p) gnupre=$OPTARG	;;
  O) BFDNAME=$OPTARG	;;
  B) BFDARCH=$OPTARG	;;
  o) cfile=$OPTARG	;;
  z) COMPRESS=yes	;;
  *) echo "bad option"
     usage
     exit 1
     ;;
  esac
done

if [ -z "$BFDNAME" -o -z "$BFDARCH" -o -z "$cfile" ]; then
  echo 'parameters -O, -B and -c are not optonal'
  usage
  exit 1
fi

# OPTIND is one to big
let "OPTIND -= 1"
shift $OPTIND

files=$*

im_dir=images
im_suf=img.o
im_table=images_table.c

if [ ! -d $im_dir ]; then
  echo "image dir not found"
  exit 1
fi

all_imgs=

# parse the images
while [ -n "$1" ]; do
  file=$1
  if [ ! -r $file ]; then
    echo "image: $file not readable"
    exit 1
  fi

  strip=yes
  fsym=$file

  if [ $file != "${file%%.bin}" ] ; then
    # do not strip files ending in .bin
      strip=no
      fsym=${file%%.bin}
  fi

  #Any Illegal character must be mapped to '_'
  sym=$(echo $(basename $fsym) | tr -c '[:alnum:]\n' '[_*]')
  all_imgs="${all_imgs} ${sym}"

  if [ $file -nt $im_dir/$sym ]; then
    if [ $strip = "yes" ]; then
      # if objcopy fails we probably have a binary image of some sort
      ${gnupre}objcopy --strip-all $file $im_dir/$sym || cp $file $im_dir/$sym
    else
      cp $file $im_dir/$sym
    fi

    if [ ! -z "$COMPRESS" ] ; then
	symin=$sym.bz2
	rm -f $im_dir/$sym.bz2
	bzip2 $im_dir/$sym
    else
	symin=$sym
    fi

    # make binary image
    cd $im_dir
    ${gnupre}objcopy --input-target=binary \
      --output-target=${BFDNAME} \
      --binary-architecture=${BFDARCH} \
      ${symin} ${sym}.${im_suf}

    if [ "$?" -ne "0" ]; then
      echo "${gnupre}objcopy: failed"
      exit 1;
    fi
      
    cd ..
  fi
  shift 1
done

im_starts=
im_sizes=
im_names=

for im in ${all_imgs}; do
    if [ ! -z "$COMPRESS" ] ; then
	im_starts="${im_starts}_binary_${im}_bz2_start, "
	im_sizes="${im_sizes}_binary_${im}_bz2_size, "
    else
	im_starts="${im_starts}_binary_${im}_start, "
	im_sizes="${im_sizes}_binary_${im}_size, "
    fi
    im_names="${im_names}\"${im}\", "
done

# now make the C file
cat -  <<EOF > $cfile
/* DO NOT EDIT!  -\*- buffer-read-only: t -*-
 * This file is automatically generated - DO NOT EDIT! */

typedef void (image_t)(void);
typedef void (*imageptr_t)(void);

extern image_t $im_starts $im_sizes __dummy;

imageptr_t image_start[]	= { $im_starts (void*)0 };

imageptr_t image_size[]	= { $im_sizes (void*)0 };

const char *image_names[] = { $im_names (void*)0 };

int image_cnt = sizeof(image_size)/sizeof(image_size[0]);

EOF
   


exit
